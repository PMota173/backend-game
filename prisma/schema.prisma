datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

generator client {
    provider = "prisma-client-js"
}

// This schema is designed to be used combined with Redis for short-lived, high-frequency state
model Player {
    id         String    @id @default(cuid())
    name       String
    gameRoom   GameRoom? @relation(fields: [gameRoomId], references: [id])
    gameRoomId String?
    score      Int       @default(0)

    answers   PlayerAnswer[]
    roles     PlayerRoleInRound[]
    votesCast PlayersVotes[]      @relation("VotesCast")
    votesRecv PlayersVotes[]      @relation("VotesRecv")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model GameRoom {
    id         String      @id @default(cuid())
    gameCode   String      @unique
    name       String
    players    Player[]
    rounds     GameRound[]
    gameStatus GameStatus  @default(WAITING)
    maxPlayers Int         @default(8)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

enum GameStatus {
    WAITING
    PLAYING
    FINISHED
}

enum RoundStatus {
    ANSWERING
    VOTING
    RESULTS
    FINISHED
}

model GameRound {
    id          String      @id @default(cuid())
    status      RoundStatus @default(ANSWERING)
    roundNumber Int
    phaseEndsAt DateTime?

    gameRoomId String
    gameRoom   GameRoom @relation(fields: [gameRoomId], references: [id])

    questionId String
    question   Question @relation(fields: [questionId], references: [id])

    roles   PlayerRoleInRound[]
    answers PlayerAnswer[]
    votes   PlayersVotes[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model PlayerAnswer {
    id       String    @id @default(cuid())
    roundId  String
    round    GameRound @relation(fields: [roundId], references: [id], onDelete: Cascade)
    playerId String
    player   Player    @relation(fields: [playerId], references: [id], onDelete: Cascade)
    answer   String

    createdAt DateTime @default(now())

    @@unique([roundId, playerId])
}

model PlayerRoleInRound {
    id       String     @id @default(cuid())
    roundId  String
    round    GameRound  @relation(fields: [roundId], references: [id], onDelete: Cascade)
    playerId String
    player   Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)
    role     PlayerRole

    createdAt DateTime @default(now())

    @@unique([roundId, playerId])
}

enum PlayerRole {
    IMPOSTOR
    NORMAL
}

model PlayersVotes {
    id       String    @id @default(cuid())
    roundId  String
    round    GameRound @relation(fields: [roundId], references: [id], onDelete: Cascade)
    voterId  String
    voter    Player    @relation("VotesCast", fields: [voterId], references: [id], onDelete: Cascade)
    targetId String
    target   Player    @relation("VotesRecv", fields: [targetId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())

    @@unique([roundId, voterId])
}

model Question {
    id               String           @id @default(cuid())
    normalQuestion   String
    impostorQuestion String
    language         QuestionLanguage @default(ENGLISH)
    createdAt        DateTime         @default(now())
    GameRound        GameRound[]
}

enum QuestionLanguage {
    ENGLISH
    SPANISH
    PORTUGUESE
}
